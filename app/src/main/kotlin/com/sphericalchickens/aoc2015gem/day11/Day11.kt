package com.sphericalchickens.aoc2015gem.day11

/**
 * # Advent of Code 2015, Day 11: Corporate Policy
 *
 * This program solves the puzzle for Day 11 of Advent of Code 2015.
 * The task is to find the next valid password, given a starting password.
 *
 * A valid password must meet three criteria:
 * 1. It must contain a straight of three increasing letters, like `abc`.
 * 2. It must not contain the letters `i`, `o`, or `l`.
 * 3. It must contain at least two different, non-overlapping pairs of letters, like `aa` and `bb`.
 *
 * This solution was generated by Gemini, based on an initial implementation.
 */
fun main() {
    println("--- Advent of Code 2015, Day 11 (Gemini) ---")

    val puzzleInput = "hxbxwxba"

    // Part 1: Find the next valid password starting from the puzzle input.
    val part1Result = nextValidPassword(puzzleInput)
    println("🎁 Part 1: $part1Result")

    // Part 2: Find the next valid password starting from the result of Part 1.
    val part2Result = nextValidPassword(part1Result)
    println("🎀 Part 2: $part2Result")
}

/**
 * Finds the next valid password by generating a sequence of passwords and
 * returning the first one that meets the validity criteria.
 *
 * @param password The starting password.
 * @return The next valid password.
 */
private fun nextValidPassword(password: String): String {
    // `generateSequence` creates a lazy sequence of passwords, starting from the
    // next password after the input. This is more idiomatic than a `while` loop.
    return generateSequence(password.increment()) { it.increment() }
        .first { it.isValid() }
}

/**
 * Increments a string as if it were a base-26 number (using the letters 'a' through 'z').
 *
 * This function is implemented using `foldRight` (by way of reversing the string
 * and using `fold`). This allows us to process the string from right to left,
 * carrying over the "increment" operation, in a functional style.
 *
 * @return The incremented string.
 */
private fun String.increment(): String {
    // We use a Pair to hold the accumulated string and the carry flag.
    return this.reversed().fold(Pair("", true)) { (acc, carry), char ->
        if (carry) {
            val nextChar = char + 1
            if (nextChar > 'z') {
                // If we've wrapped around past 'z', the new character is 'a' and we continue to carry.
                Pair("a$acc", true)
            } else {
                // Otherwise, we've found the new character and can stop carrying.
                Pair("$nextChar$acc", false)
            }
        } else {
            // If we're not carrying, just prepend the character to the accumulator.
            Pair("$char$acc", false)
        }
    }.let { (result, carry) ->
        // If there's still a carry after the fold (e.g., "zzz" -> "aaaa"), prepend an 'a'.
        if (carry) "a$result" else result
    }
}

/**
 * Checks if a password is valid by ensuring it meets all three criteria.
 *
 * @return `true` if the password is valid, `false` otherwise.
 */
private fun String.isValid(): Boolean {
    return hasStraight() && hasNoForbiddenLetters() && hasTwoPairs()
}

/**
 * Checks if the password contains a straight of three increasing letters (e.g., "abc").
 *
 * We use the `windowed` function to get all substrings of length 3, and then
 * check if any of them are a straight.
 *
 * @return `true` if the password contains a straight, `false` otherwise.
 */
private fun String.hasStraight(): Boolean {
    return windowed(3).any { it[0] + 1 == it[1] && it[1] + 1 == it[2] }
}

/**
 * Checks if the password contains any of the forbidden letters ('i', 'o', 'l').
 *
 * @return `true` if the password has no forbidden letters, `false` otherwise.
 */
private fun String.hasNoForbiddenLetters(): Boolean {
    return none { it in "iol" }
}

/**
 * Checks if the password contains at least two different, non-overlapping pairs of letters.
 *
 * This is done using a regular expression to find all pairs of repeated characters.
 * We then count the number of distinct pairs.
 *
 * @return `true` if the password has at least two pairs, `false` otherwise.
 */
private fun String.hasTwoPairs(): Boolean {
    // The regex "(.)\1" finds any character followed by itself.
    // We use a raw string (""") to avoid having to escape the backslash.
    return Regex("""(.)\1""").findAll(this).map { it.value }.distinct().count() >= 2
}