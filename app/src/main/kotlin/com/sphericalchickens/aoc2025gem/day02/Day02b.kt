package com.sphericalchickens.aoc2025gem.day02

import com.sphericalchickens.utils.check
import com.sphericalchickens.utils.readInputText
import kotlin.math.max
import kotlin.math.min
import kotlin.math.pow
import kotlin.time.measureTimedValue


/**
 * Note: This was generated with help from Gemini.  Though the algorithm was my original idea.
 */

fun main() {
    println("--- Advent of Code 2025, Day 2 (Generative Approach) ---")
    val input = readInputText("aoc2025/day02_input.txt")

    runTests()

    val t1 = measureTimedValue {
        println("Part 1: ${part1(input)}")
    }
    println("Part 1 runtime: ${t1}ms")

    val t2 = measureTimedValue {
        println("Part 2: ${part2(input)}")
    }
    println("Part 2 runtime: ${t2}ms")
}

private fun runTests() {
    val testInput = """
        11-22,95-115,998-1012,1188511880-1188511890,222220-222224,
        1698522-1698528,446443-446449,38593856-38593862,565653-565659,
        824824821-824824827,2121212118-2121212124
    """.trimIndent().replace("\n", "")

    // Unit tests for the Repunit Logic
    // For Length 4, Period 2 ("1212"), Repunit should be 101
    check("Repunit L4 P2", 101L, calculateRepunit(4, 2))
    // For Length 6, Period 2 ("121212"), Repunit should be 10101
    check("Repunit L6 P2", 10101L, calculateRepunit(6, 2))

    // Integration tests
    check("Part 1 Test Case 1", 1227775554L, part1(testInput))
    check("Part 2 Test Case 1", 4174379265L, part2(testInput))

    println("âœ… All tests passed!")
}

private fun part1(input: String): Long {
    // For Part 1, we only look for period = length / 2
    return parseRanges(input).sumOf { range ->
        generatePatternNumbers(range) { totalLength ->
            // Only valid if length is even, and period is exactly half
            if (totalLength % 2 == 0) listOf(totalLength / 2) else emptyList()
        }
    }
}

private fun part2(input: String): Long {
    // For Part 2, we look for any period P that divides Length L
    return parseRanges(input).sumOf { range ->
        generatePatternNumbers(range) { totalLength ->
            // Find all divisors of totalLength (excluding totalLength itself)
            (1..totalLength / 2).filter { totalLength % it == 0 }
        }
    }
}

/**
 * Generates valid pattern numbers within the given range based on the allowed periods.
 * This effectively solves "Roots * Repunit = Target" for the Roots.
 */
private fun generatePatternNumbers(range: LongRange, periodStrategy: (Int) -> List<Int>): Long {
    val start = range.first
    val end = range.last
    val startLen = start.toString().length
    val endLen = end.toString().length

    // We use a Set to handle overlaps in Part 2.
    // E.g., "1111" is generated by Period 1 (Root "1") and Period 2 (Root "11").
    // The Set ensures we count it only once per range.
    val foundNumbers = HashSet<Long>()

    for (len in startLen..endLen) {
        val periods = periodStrategy(len)
        for (p in periods) {
            val repunit = calculateRepunit(len, p)

            // Determine valid range for the "Root" number.
            // 1. Root must result in a number >= Range Start
            val minRootByValue = (start + repunit - 1) / repunit // Ceil division
            // 2. Root must result in a number <= Range End
            val maxRootByValue = end / repunit

            // 3. Root must have exactly 'p' digits.
            //    Using Double pow is safe here as p is small (digits < 19 for Long)
            val minRootByDigits = 10.0.pow(p - 1).toLong()
            val maxRootByDigits = 10.0.pow(p).toLong() - 1

            // Intersect the constraints
            val actualMin = max(minRootByValue, minRootByDigits)
            val actualMax = min(maxRootByValue, maxRootByDigits)

            if (actualMin <= actualMax) {
                for (root in actualMin..actualMax) {
                    foundNumbers.add(root * repunit)
                }
            }
        }
    }
    return foundNumbers.sum()
}

/**
 * Calculates the multiplier K such that Root * K = Repeated Pattern.
 * e.g., if we want "12" to become "121212" (Len 6, Period 2),
 * we need K = 10101.
 *
 * Formula: K = Sum(10^(i*p)) for i steps.
 * This is a geometric series sum: (10^L - 1) / (10^p - 1).
 */
private fun calculateRepunit(len: Int, period: Int): Long {
    // Simple iterative sum is safer against overflow/precision issues than Pow division for Longs
    var k = 0L
    var currentShift = 0
    while (currentShift < len) {
        // We can't use 10.0.pow here easily for Long precision at high powers,
        // but 10^18 fits in Long.
        // We construct the repunit (e.g., 10101) iteratively.
        // 1
        // 100 + 1 = 101
        // 10000 + 101 = 10101

        // Actually, simpler logic:
        // Period 2, Len 6: 1 + 100 + 10000
        var term = 1L
        for(i in 0 until currentShift) term *= 10
        k += term
        currentShift += period
    }
    return k
}

private fun parseRanges(input: String): Sequence<LongRange> {
    return input.splitToSequence(',')
        .map { it.trim() }
        .filter { it.isNotEmpty() }
        .map { token ->
            val separatorIndex = token.indexOf('-')
            val start = token.substring(0, separatorIndex).toLong()
            val end = token.substring(separatorIndex + 1).toLong()
            start..end
        }
}