package com.sphericalchickens.aoc2016gem.day13

import com.sphericalchickens.utils.check
import com.sphericalchickens.utils.readInputLines
import kotlin.system.measureTimeMillis

/**
 * The main function remains structurally identical to your original.
 * It provides excellent control over running tests and solutions, and includes timing.
 * The only change is that it now calls our new, refactored part1 and part2 functions.
 */
fun main() {
    // --- Development Workflow Control Panel ---
    val runPart1Tests = true
    val runPart1Solution = true
    val runPart2Solution = true
    // ----------------------------------------

    println("--- Advent of Code 2016, Day 13 ---")

    val input = readInputLines("aoc2016/day13_input.txt")
    val magicNumber = input.first().toInt()
    val part1Goal = Vector(31, 39)

    // --- Part 1 ---
    if (runPart1Tests) {
        println("üß™ Running Part 1 tests...")
        runPart1Tests()
        println("‚úÖ Part 1 tests passed!")
    }
    if (runPart1Solution) {
        println("üéÅ Solving Part 1...")
        val timeInMillis = measureTimeMillis {
            val part1Result = part1(magicNumber, part1Goal)
            println("   Part 1: $part1Result")
        }
        println("Part 1 runtime: $timeInMillis ms.")
    }

    // --- Part 2 ---
    if (runPart2Solution) {
        println("üéÄ Solving Part 2...")
        val timeInMillis = measureTimeMillis {
            val part2Result = part2(magicNumber)
            println("   Part 2: $part2Result")
        }
        println("Part 2 runtime: $timeInMillis ms.")
    }
}

/**
 * The Vector data class is a perfect use case for a `data class`.
 * It's simplified, as the `isWall` logic is now managed by the Maze class.
 * We add a convenient `neighbors()` function to make the BFS traversal logic cleaner.
 */
private data class Vector(val x: Int, val y: Int) {
    operator fun plus(other: Vector) = Vector(this.x + other.x, this.y + other.y)

    /** Returns the four cardinal neighbors. */
    fun neighbors(): List<Vector> = listOf(
        this + Vector(-1, 0), // Left
        this + Vector(1, 0),  // Right
        this + Vector(0, -1), // Up
        this + Vector(0, 1)   // Down
    )
}

/**
 * This is the primary refactoring. We introduce a `Maze` class to encapsulate
 * all state and logic related to the puzzle.
 *
 * 1. It holds the `magicNumber` as an immutable `private val`.
 * 2. It contains the `wallCache` to avoid recomputing `isWall` for the same location.
 * 3. It provides public functions to solve the specific parts of the problem.
 *
 * This completely eliminates the need for global mutable state.
 */
private class Maze(private val magicNumber: Int) {

    private val wallCache = mutableMapOf<Vector, Boolean>()

    /**
     * A private helper that performs the raw "wall" calculation.
     * We use Longs for the intermediate calculation, just as in the original,
     * to prevent any possibility of integer overflow.
     *
     * I've also arithmetically simplified the formula:
     * x*x + 3*x + 2*x*y + y + y*y  ==> (x+y)*(x+y) + 3*x + y
     *
     * We use the highly idiomatic and efficient `countOneBits()` function,
     * which compiles to a CPU intrinsic, instead of converting to a String.
     */
    private fun computeIsWall(x: Int, y: Int): Boolean {
        val longX = x.toLong()
        val longY = y.toLong()
        val sum = (longX + longY) * (longX + longY) + 3 * longX + longY
        // `countOneBits()` is the idiomatic way to count set bits.
        // We check if the count is odd.
        return (sum + magicNumber).countOneBits() % 2 == 1
    }

    /**
     * Public-facing `isWall` check that uses the cache.
     * `getOrPut` is a perfect idiomatic Kotlin function for this caching pattern.
     */
    fun isWall(v: Vector): Boolean {
        // We don't need to check for negative coordinates here;
        // the BFS traversals will handle that.
        return wallCache.getOrPut(v) { computeIsWall(v.x, v.y) }
    }

    /**
     * Reconstructs the path from the end goal back to the start
     * using the predecessor map generated by the BFS.
     * This is the new helper function.
     */
    private fun reconstructPath(
        start: Vector,
        goal: Vector,
        predecessors: Map<Vector, Vector>
    ): List<Vector> {
        val path = mutableListOf<Vector>()
        var current = goal
        while (current != start) {
            path.add(current)
            // We can use the !! non-null assertion safely here, because the BFS
            // algorithm guarantees that any node in the path (except start)
            // MUST have a predecessor.
            current = predecessors[current]
                ?: error("Path reconstruction failed: no predecessor for $current")
        }
        path.add(start)
        return path.reversed()
    }

    /**
     * An optimized BFS for Part 1.
     * It now returns the path (as a List<Vector>) instead of just the distance.
     * It returns an empty list if the goal is not reachable.
     */
    fun findShortestPath(start: Vector, goal: Vector): List<Vector> {
        // The queue now only needs to store the location.
        val queue = ArrayDeque<Vector>()
        val visited = mutableSetOf<Vector>()
        // This is the new map to store where we came from.
        val predecessors = mutableMapOf<Vector, Vector>()

        if (isWall(start)) return emptyList()
        if (start == goal) return listOf(start)

        queue.add(start)
        visited.add(start)

        while (queue.isNotEmpty()) {
            val current = queue.removeFirst()

            // Path found! Reconstruct it and return.
            if (current == goal) {
                return reconstructPath(start, goal, predecessors)
            }

            for (neighbor in current.neighbors()) {
                // Standard BFS checks
                if (neighbor.x < 0 || neighbor.y < 0) continue // Out of bounds
                if (neighbor in visited) continue               // Already seen
                if (isWall(neighbor)) continue                  // Hit a wall

                // This is a valid, new, open location.
                visited.add(neighbor)
                predecessors[neighbor] = current // <-- This is the key change
                queue.add(neighbor)
            }
        }
        return emptyList() // Goal not reachable
    }

    /**
     * A new helper function to print the maze, highlighting the path
     * and marking the start and goal with ANSI colors.
     */
    fun showPath(path: List<Vector>, goal: Vector) {
        // ANSI Color Codes for the terminal
        val red = "\u001b[31m"
        val green = "\u001b[32m"
        val blue = "\u001b[34m"
        val reset = "\u001b[0m"

        val pathSet = path.toSet()
        // Determine bounds based on the path AND the goal, with a little padding.
        val maxX = maxOf(path.maxOfOrNull { it.x } ?: 0, goal.x) + 2
        val maxY = maxOf(path.maxOfOrNull { it.y } ?: 0, goal.y) + 2
        val start = path.firstOrNull()

        for (y in 0..maxY) {
            val row = buildString {
                for (x in 0..maxX) {
                    val v = Vector(x, y)
                    // We now append the string directly, including color codes
                    when {
                        v == start -> append("${red}S${reset}")
                        v == goal -> append("${green}G${reset}")
                        v in pathSet -> append("${blue}o${reset}")
                        isWall(v) -> append('#')
                        else -> append(' ') // Changed from '.' to ' '
                    }
                }
            }
            println("     $row") // Indent the map
        }
    }

    /**
     * An optimized BFS for Part 2.
     * It explores all locations reachable within `maxSteps` and returns
     * the set of all visited locations (including the start).
     */
    fun findLocationsWithin(start: Vector, maxSteps: Int): Set<Vector> {
        val visited = mutableSetOf<Vector>()
        val queue = ArrayDeque<Pair<Vector, Int>>() // Pair(location, distance)

        if (isWall(start)) return emptySet()

        visited.add(start)
        queue.add(start to 0)

        while (queue.isNotEmpty()) {
            val (current, dist) = queue.removeFirst()

            // If we are at the step limit, we add this node to `visited`
            // (which happened when it was enqueued), but we do NOT
            // explore its neighbors.
            if (dist == maxSteps) continue

            val newDist = dist + 1
            for (neighbor in current.neighbors()) {
                if (neighbor.x < 0 || neighbor.y < 0) continue
                if (neighbor in visited) continue
                if (isWall(neighbor)) continue

                visited.add(neighbor)
                queue.add(neighbor to newDist)
            }
        }
        return visited
    }
}

/**
 * The test function is updated to use the new `Maze` class.
 * It no longer needs to set any global state.
 */
private fun runPart1Tests() {
    val testMaze = Maze(10)
    check("6,2 is open", false, testMaze.isWall(Vector(2, 6)))
    check("2,1 is wall", true, testMaze.isWall(Vector(2, 1)))

    // The part1 function will create its own Maze(10) internally.
    check("Part 1 Test Case 1", 11, part1(10, Vector(7, 4)))
}

/**
 * `part1` is now a clean, simple function.
 * It creates a `Maze` instance, calls the new `findShortestPath`,
 * and then prints the path before returning the distance.
 */
private fun part1(n: Int, goal: Vector): Int {
    val maze = Maze(n)
    val path = maze.findShortestPath(Vector(1, 1), goal)

    // Only print the path visualization for the real solution,
    // not for the test case (which has n=10).
    if (path.isNotEmpty() && n != 10) {
        println("   Path visualization:")
        maze.showPath(path, goal)
    }

    // The result is the number of steps, which is path size - 1.
    // Return -1 if no path was found.
    return if (path.isEmpty()) -1 else (path.size - 1)
}

/**
 * `part2` is also cleaned up. It creates a `Maze` and calls
 * the `findLocationsWithin` method, returning the size of the resulting set.
 */
private fun part2(n: Int): Int {
    val maze = Maze(n)
    return maze.findLocationsWithin(Vector(1, 1), 50).size
}


